import config as cfg
import utils
import base
import weather_connector
import tg_api_connector
from not_found_messages import not_found_weather_texts
from not_found_messages import not_found_weather_image_text

import io
import json
import tests
import random
from enum import Enum, auto
from typing import Any, NamedTuple, Optional
from functools import cache


class EventType(Enum):
    SCHEDULED = auto()
    CITY = auto()
    ADD_CITIES = auto()
    CLEAR_CITIES = auto()
    SHOW_CITIES = auto()
    LIST_CITIES = auto()
    SWITCH_DARKMODE = auto()
    OTHER = auto()


class EventData(NamedTuple):
    type: EventType
    chat_id: int
    city_names: list[str]


def parse_event(event) -> EventData:
    default_city_name = cfg.DEFAULT_CITY
    if event.get('detail-type') == 'Scheduled Event':  # event initiated by Event Bridge
        return EventData(EventType.SCHEDULED, None, [])
    elif event.get('httpMethod') in (
        'GET',
        'POST',
    ):  # event initiated by telegram via http api gateway
        update = event.get('body')
        assert update
        update = json.loads(update)
        utils.print_with_time(update)
        key = 'message'
        if key in update:
            chat_id = int(update[key]['chat']['id'])
            # message_type = update[key].get('entities',[{}])[0].get('type')
            
            text = update[key].get('text', '')
            if not text:
                return EventData(EventType.OTHER, None, [])
            text = bytes(text, 'utf-8').decode('utf-8').strip()
            
            is_private = update[key]['chat'].get('type') == 'private'
            if is_private and not text.startswith('/'):
                text = '/' + text

            bot_mention_position = text.find(f'@{cfg.BOT_NAME}')
            if bot_mention_position != -1:
                text = text[:bot_mention_position].strip()

            if text == '/dark':
                return EventData(EventType.SWITCH_DARKMODE, chat_id, [])
            
            if text == '/clear':
                return EventData(EventType.CLEAR_CITIES, chat_id, [])
            
            if text == '/list':
                return EventData(EventType.LIST_CITIES, chat_id, [])
            
            if text == '/show':
                return EventData(EventType.SHOW_CITIES, chat_id, [])
            
            if text.startswith('/add'):
                city_names = text[len('/add'):].strip().split(',')
                city_names = [city.strip() for city in city_names if city]
                return EventData(EventType.ADD_CITIES, chat_id, city_names)

            
            if text.startswith('/') and len(text) > 2:  # city command
                text = text[1:].strip()
                city_name = text.strip()
                if len(city_name) > 1:
                    return EventData(EventType.CITY, chat_id, [city_name])
            return EventData(EventType.CITY, chat_id, [default_city_name])
    return EventData(EventType.OTHER, None, [])


def update_db(event_data: EventData) -> Any:
    if event_data.type is EventType.SWITCH_DARKMODE:
        feedback = base.switch_darkmode(event_data.chat_id)
    elif event_data.type is EventType.ADD_CITIES:
        feedback = base.add_cities(event_data.chat_id, event_data.city_names)
    elif event_data.type is EventType.CLEAR_CITIES:
        feedback = base.clear_cities(event_data.chat_id)
    else:
        assert False
    return feedback
    

def lambda_handler(event: dict, context) -> dict:
    event_data = parse_event(event)
    
    success = {'statusCode': 200, 'body': 'Success'}
    
    if event_data.type is EventType.OTHER:
        return success
    elif event_data.type is EventType.SCHEDULED:
        chats_with_params = base.get_chats_with_params()
        for chat_id, chat_info in chats_with_params.items():
            dark_mode = chat_info.get('dark_mode', cfg.DEFAULT_DARKMODE)
            city_names = chat_info.get('cities', [])
            for city_name in city_names:
                text, image = create_message(city_name, dark_mode)
                tg_api_connector.send_message({chat_id}, text, image)
        return success

    if event_data.type in (EventType.SWITCH_DARKMODE, EventType.ADD_CITIES, EventType.CLEAR_CITIES):
        db_update_feedback = update_db(event_data)

    assert event_data.type in (EventType.ADD_CITIES, EventType.CITY, EventType.CLEAR_CITIES, 
            EventType.LIST_CITIES, EventType.SHOW_CITIES, EventType.SWITCH_DARKMODE)

    chat_id = event_data.chat_id
    
    if event_data.type is EventType.SWITCH_DARKMODE:
        dark_mode = db_update_feedback
        text = f'–¢–µ–ø–µ—Ä—å –∫–∞—Ä—Ç–∏–Ω–∫–∞ –±—É–¥–µ—Ç {"—Ç—ë–º–Ω–∞—è" if dark_mode else "—Å–≤–µ—Ç–ª–∞—è"}'
        tg_api_connector.send_message({chat_id}, text, None)
        return success
    
    assert event_data.type in (EventType.ADD_CITIES, EventType.CLEAR_CITIES, 
            EventType.LIST_CITIES, EventType.SHOW_CITIES, EventType.CITY)
    
    if event_data.type in (EventType.CLEAR_CITIES, EventType.ADD_CITIES):
        if event_data.type is EventType.CLEAR_CITIES:
            text = f'–ù–∞–ø–æ–º–∏–Ω–∞–ª–∫–∏ –æ–±–æ –≤—Å–µ—Ö –≥–æ—Ä–æ–¥–∞—Ö —É–¥–∞–ª–µ–Ω—ã'
        elif event_data.type is EventType.ADD_CITIES:
            city_names = event_data.city_names
            old_without_new_cities = db_update_feedback
            if not city_names or not city_names[0]:
                text = f'–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ. –ö–∞–∂–µ—Ç—Å—è, –≤—ã –Ω–∞–∂–∞–ª–∏ –∫–æ–º–∞–Ω–¥—É\n\n/add\n\n–≤ –º–µ–Ω—é.' \
                        f' –í–∞–º-—Ç–æ —Ö–æ—Ä–æ—à–æ, –Ω–∞–∂–∞–ª–∏ –∏ –Ω–∞–∂–∞–ª–∏. –ê –Ω–∞—à –¥–µ–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç' \
                        f' –Ω–∞ —É—à–∞—Ö: –≤—Å–µ —Ö–æ—Ç—è—Ç –∑–Ω–∞—Ç—å, –∫–∞–∫–æ–π –≥–æ—Ä–æ–¥ –≤—ã —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å' \
                        f' –≤ –Ω–∞–ø–æ–º–∏–Ω–∞–ª–∫–∏. –í—Å–µ –±–µ–≥–∞—é—Ç, —à—É–º—è—Ç, –≤–æ–ª–æ—Å—ã —Ä–≤—É—Ç. ' \
                        f' –°—Ç–∞–≤–∫–∏ –¥–µ–ª–∞—é—Ç, –º–æ—Ä–¥—ã –±—å—é—Ç. –ò –Ω–∏–∫—Ç–æ –Ω–∏—á–µ–≥–æ' \
                        f' –Ω–µ –∑–Ω–∞–µ—Ç, –Ω–∏–∫—Ç–æ –Ω–µ –∑–∞ —á—Ç–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç. –ß—Ç–æ –∑–∞ –Ω–∞—Ä–æ–¥!' \
                        f' –º–æ–∂–Ω–æ –≤–∞—Å –ø–æ–ø—Ä–æ—Å–∏—Ç—å —Å–∫–∞–∑–∞—Ç—å –∏–º —É–∂–µ –≥–æ—Ä–æ–¥, –∞ —Ç–æ –æ–Ω–∏ –≤—Å—ë —Ç—É—Ç —Ä–∞–∑–Ω–µ—Å—É—Ç?' \
                        f' –ù—É, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–∞–∫: \n\n/add –Ø—Ä–æ—Å–ª–∞–≤–ª—å'
            else:
                text = f'–ë—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å –æ {", ".join(city_names)} –ø–æ —É—Ç—Ä–∞–º'
                if old_without_new_cities:
                    text += '. A –µ—â—ë –æ ' + ', '.join(old_without_new_cities)
        
        tg_api_connector.send_message({chat_id}, text, None)
        return success

    assert event_data.type in (EventType.LIST_CITIES, EventType.SHOW_CITIES, EventType.CITY)
    
    chats_with_params = base.get_chats_with_params()
    
    if event_data.type is EventType.LIST_CITIES:
        city_names = chats_with_params.get(chat_id, {}).get('cities', [])
        if not city_names:
            text = f'–í—ã –ø—Ä–æ—Å–∏–ª–∏ –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å –æ –ø—É—Å—Ç–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ –≥–æ—Ä–æ–¥–æ–≤! –ë—É–¥–µ—Ç —Å–¥–µ–ª–∞–Ω–æ! ü´°'
        else:
            text = f'–ö–∞–∂–µ—Ç—Å—è, –≤—ã –ø—Ä–æ—Å–∏–ª–∏ –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å –æ ' + ', '.join(city_names) + '. –û—Ö, –≤—Å–µ–≥–æ-—Ç–æ –Ω–µ —É–ø–æ–º–Ω–∏—à—å ...'
        
        tg_api_connector.send_message({chat_id}, text, None)
        return success

    assert event_data.type in (EventType.CITY, EventType.SHOW_CITIES)
    
    if event_data.type is EventType.CITY:
        city_names = event_data.city_names
        if len(city_names) == 1 and city_names[0] == 'city':
            text = '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ –º–µ—Ç–µ–æ—Å—Ç–∞–Ω—Ü–∏—é. –†–∞—Å–ø–æ–ª–∞–≥–∞–π—Ç–µ—Å—å,' \
                f' —á–∞–π–∫—É? –£–Ω—Ç—ã –Ω–µ —Å—Ç–∞–≤—å—Ç–µ –±–ª–∏–∑–∫–æ –∫ –∫–∞–º–∏–Ω—É, —Å—è–¥—É—Ç-—Å ... ' \
                f' –í—ã –∫–∞–∫–∏–µ —Å–∏–≥–∞—Ä—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ, La Gloria Cubana? Romeo y Julieta?' \
                f' –ü—Ä–æ—Å—Ç–∏—Ç–µ, –∫–æ–Ω–µ—á–Ω–æ, –ø–µ—Ä–µ—Ö–æ–∂—É –∫ –≤–∞—à–µ–º—É –¥–µ–ª—É.' \
                f' –í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏—Ç–µ –ø–æ—Å–ª–∞—Ç—å –≥–æ–Ω—Ü–æ–≤ –≤ –≥–æ—Ä–æ–¥ city? –ù–µ—Ç, –º–æ–∏ –ø–∞—Ä–Ω–∏ –º–æ–≥—É—Ç' \
                f' –∏ –Ω–µ —Ç–∞–∫–æ–µ, –∏ —Å–æ–±–∞–∫–∏ —Ö–æ—Ä–æ—à–æ –æ—Ç–¥–æ—Ö–Ω—É–ª–∏. –¢–æ–ª—å–∫–æ, –≤–æ—Ç, –Ω–µ —Ö–æ—Ç–∏—Ç–µ –ª–∏,' \
                f' –≤–º–µ—Å—Ç–æ –º–∏—Ñ–∏—á–µ—Å–∫–æ–≥–æ\n\n/city\n\n, —É–∑–Ω–∞—Ç—å –ø–æ–≥–æ–¥—É –≤ –≥–æ—Ä–æ–¥–µ\n\n/–û–π–º—è–∫–æ–Ω\n\n' \
                f'? –ò–ª–∏, –¥–æ–ø—É—Å—Ç–∏–º, –≤\n\n/–ú–æ–≥–∞–¥–∏—à–æ\n\n? –í—ã, –∫—Å—Ç–∞—Ç–∏, –±—ã–ª–∏ –≤ –ú–æ–≥–∞–¥–∏—à–æ?' \
                f' –Ø –≤–æ—Ç –≤–∞–º –æ—á–µ–Ω—å —Å–æ–≤–µ—Ç—É—é. –û—á–µ–Ω—å, –∑–Ω–∞–µ—Ç–µ –ª–∏, —Ö–æ—Ä–æ—à–µ–µ –º–µ—Å—Ç–æ, —á—Ç–æ–±—ã —Ç–∞–º' \
                f' –Ω–µ –±—ã–≤–∞—Ç—å. –Ø –≤–æ—Ç —Ç–∞–º –Ω–µ –±—ã–ª –∏ –≤–∏–¥–∏—Ç–µ, –∫–∞–∫ –º–Ω–µ —ç—Ç–æ –ø–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å ...' \
                f' –≠—Ö, –¥–∞ ... –í–æ—Ç –∂–µ –∂ –∫–∞–∫–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–µ –±—ã–ª–æ ... –•–æ—Ä–æ—à–æ.'
            tg_api_connector.send_message({chat_id}, text, None)
            return success    
    elif event_data.type is EventType.SHOW_CITIES:
        city_names = chats_with_params.get(chat_id, {}).get('cities', [])
    
    if not city_names:
        text = '–°–µ–π—á–∞—Å-—Å–µ–π—á–∞—Å ... –±–µ–≥—É ... –æ–π, –∞ –Ω–∏ –æ–¥–Ω–æ–≥–æ' \
                f' –≥–æ—Ä–æ–¥–∞-—Ç–æ –≤—ã –∏ –Ω–µ –∑–∞–∫–∞–∑—ã–≤–∞–ª–∏ ...'        
        tg_api_connector.send_message({chat_id}, text, None)
        return success
    
    dark_mode = chats_with_params.get(chat_id, {}).get('dark_mode', cfg.DEFAULT_DARKMODE)
    
    for city_name in city_names:
        text, image = create_message(city_name, dark_mode)
        tg_api_connector.send_message({chat_id}, text, image)

    return success






    
    # elif event_data.type is EventType.SWITCH_DARKMODE:
    #     chat_id = event_data.chat_id
    #     dark_mode = base.switch_darkmode(chat_id)
    #     text = f'–¢–µ–ø–µ—Ä—å –∫–∞—Ä—Ç–∏–Ω–∫–∞ –±—É–¥–µ—Ç {"—Ç—ë–º–Ω–∞—è" if dark_mode else "—Å–≤–µ—Ç–ª–∞—è"}'
    #     tg_api_connector.send_message({chat_id}, text, None)
    
    # elif event_data.type is EventType.SCHEDULED:
    #     # if event_data.chat_id:
    #     #     chat_id = event_data.chat_id
    #     #     chats_with_params = base.get_chat_with_params(chat_id)
    #     #     if not chats_with_params or not chats_with_params[0].get('cities'):
    #     #         text = '–°–µ–π—á–∞—Å-—Å–µ–π—á–∞—Å ... –±–µ–≥—É ... –æ–π, –∞ –Ω–∏ –æ–¥–Ω–æ–≥–æ' \
    #     #                 f' –≥–æ—Ä–æ–¥–∞-—Ç–æ –≤—ã –∏ –Ω–µ –∑–∞–∫–∞–∑—ã–≤–∞–ª–∏ ...'
    #     #         tg_api_connector.send_message({chat_id}, text, None)
    #     # else:
    #     #     chats_with_params = base.get_chats_with_params()
        
    #     for chat_info in chats_with_params:
    #         chat_id = chat_info['id']
    #         dark_mode = chat_info.get('dark_mode', False)
    #         city_names = chat_info.get('cities', [])
    #         for city_name in city_names:
    #             text, image = create_message(city_name, dark_mode)
    #             tg_api_connector.send_message({chat_id}, text, image)
    
    # elif event_data.type is EventType.CITY:
    #     chat_id = event_data.chat_id
    #     city_name = event_data.city_names[0]
        
    #     chats_with_params = base.get_chats_with_params()
    #     base.add_chat(chat_id)
        
    #     dark_mode = cfg.DEFAULT_DARKMODE
    #     for chat_info in chats_with_params:
    #         if chat_info['id'] == chat_id:
    #             dark_mode = chat_info.get('dark_mode', cfg.DEFAULT_DARKMODE)
    #             break
        
    #     text, image = create_message(city_name, dark_mode)
    #     tg_api_connector.send_message({chat_id}, text, image)
        
    # elif event_data.type is EventType.ADD_CITIES:
    #     chat_id = event_data.chat_id
    #     city_names = event_data.city_names

    #     old_without_new_cities = base.add_cities(chat_id, city_names)
    #     text = f'–ë—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å –æ {", ".join(city_names)} –ø–æ —É—Ç—Ä–∞–º'
    #     if old_without_new_cities:
    #         text += '. A –µ—â—ë –æ ' + ', '.join(old_without_new_cities)
        
    #     tg_api_connector.send_message({chat_id}, text, None)
    # elif event_data.type is EventType.CLEAR_CITIES:
    #     chat_id = event_data.chat_id
        
    #     base.clear_cities(chat_id)
    #     text = f'–ù–∞–ø–æ–º–∏–Ω–∞–ª–∫–∏ –æ–±–æ –≤—Å–µ—Ö –≥–æ—Ä–æ–¥–∞—Ö —É–¥–∞–ª–µ–Ω—ã'
    #     tg_api_connector.send_message({chat_id}, text, None)
        
    # elif event_data.type is EventType.LIST_CITIES:
    #     chat_id = event_data.chat_id
    #     cities = base.list_cities(chat_id)
    #     if not cities:
    #         text = f'–í—ã –ø—Ä–æ—Å–∏–ª–∏ –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å –æ –ø—É—Å—Ç–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ –≥–æ—Ä–æ–¥–æ–≤! –ë—É–¥–µ—Ç —Å–¥–µ–ª–∞–Ω–æ! ü´°'
    #     else:
    #         text = f'–ö–∞–∂–µ—Ç—Å—è, –≤—ã –ø—Ä–æ—Å–∏–ª–∏ –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å –æ ' + ', '.join(cities) + '. –û—Ö, –≤—Å–µ–≥–æ-—Ç–æ –Ω–µ —É–ø–æ–º–Ω–∏—à—å ...'
        
    #     tg_api_connector.send_message({chat_id}, text, None)
        
    # else:
    #     assert False

    # utils.print_with_time(f'sent messages to chats')
    # return success


@cache
def create_message(city_name: str, dark_mode: bool) -> \
        tuple[str, Optional[io.BytesIO]]:
    weather_text = weather_connector.get_weather_text(city_name)
    weather_image = weather_connector.get_weather_image(city_name, dark_mode)
    
    not_found_start = f'{city_name}, –≥–æ–≤–æ—Ä–∏—Ç–µ ... \n\n'
    
    if weather_text == '':
        text_body = random.choice(not_found_weather_texts)
        weather_text = not_found_start + text_body

    if weather_image is None:
        if not weather_text.startswith(not_found_start):
            weather_text += not_found_weather_image_text
    
    return weather_text, weather_image


if __name__ == '__main__':
    for k, v in tests.__dict__.items():
        if k.startswith('test_') and isinstance(v, dict):
            lambda_handler(v, None)